(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{480:function(s,t,a){s.exports=a.p+"assets/img/clip_image001.18d8525a.gif"},537:function(s,t,a){"use strict";a.r(t);var r=a(16),e=Object(r.a)({},(function(){var s=this,t=s.$createElement,r=s._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[r("h2",{attrs:{id:"redis是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis是什么"}},[s._v("#")]),s._v(" redis是什么？")]),s._v(" "),r("p",[s._v("Redis是一款基于内存的高速缓存数据库，使用C语言编写，Redis是一个key-value存储系统（键值存储系统）")]),s._v(" "),r("h2",{attrs:{id:"redis使用场景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis使用场景"}},[s._v("#")]),s._v(" redis使用场景")]),s._v(" "),r("ul",[r("li",[s._v("热点数据的缓存")]),s._v(" "),r("li",[s._v("限时业务")]),s._v(" "),r("li",[s._v("秒杀业务")]),s._v(" "),r("li",[s._v("分布式锁[秒杀]")]),s._v(" "),r("li",[s._v("延时操作[发布订阅]")]),s._v(" "),r("li",[s._v("排行榜业务")]),s._v(" "),r("li",[s._v("点赞、好友等相互关系的存储")]),s._v(" "),r("li",[s._v("简单队列[当然RabbitMQ]")])]),s._v(" "),r("h2",{attrs:{id:"redis的数据类型有哪些"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis的数据类型有哪些"}},[s._v("#")]),s._v(" redis的数据类型有哪些？")]),s._v(" "),r("p",[s._v("String字符串,List列表，Set集合，Hash散列，Zset有序集合，geospatial地理位置，Bitmaps位图，HyperLogLogs基数统计，Stream消息队列")]),s._v(" "),r("h2",{attrs:{id:"什么是单线程-io多路复用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是单线程-io多路复用"}},[s._v("#")]),s._v(" 什么是单线程，IO多路复用？")]),s._v(" "),r("p",[s._v("Redis是单线程+多路IO复用技术")]),s._v(" "),r("p",[s._v("多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）")]),s._v(" "),r("p",[s._v("串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis)")]),s._v(" "),r("p",[s._v("（与Memcache三点不同: 支持多数据类型，支持持久化，单线程+多路IO复用）")]),s._v(" "),r("p",[r("img",{attrs:{src:a(480),alt:"img"}})]),s._v(" "),r("h2",{attrs:{id:"redis的特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis的特点"}},[s._v("#")]),s._v(" redis的特点？")]),s._v(" "),r("p",[s._v("要更新redis，直接清空缓存，再往里面添加")]),s._v(" "),r("blockquote",[r("p",[s._v("因为redis做查询非常非常快，修改反而没有全删再加入快")])]),s._v(" "),r("h2",{attrs:{id:"redis的原子性是如何保证的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis的原子性是如何保证的"}},[s._v("#")]),s._v(" redis的原子性是如何保证的？")]),s._v(" "),r("p",[s._v("redis本身单线程的，所以就保证了原子性")]),s._v(" "),r("p",[s._v("redis的事务功能保证了批量操作的原子性")]),s._v(" "),r("h3",{attrs:{id:"介绍一下reids的事务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下reids的事务"}},[s._v("#")]),s._v(" 介绍一下reids的事务")]),s._v(" "),r("h2",{attrs:{id:"什么是延迟双删策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是延迟双删策略"}},[s._v("#")]),s._v(" 什么是延迟双删策略？")]),s._v(" "),r("blockquote",[r("p",[s._v("保证Redis数据和MySQL数据库的一致性")])]),s._v(" "),r("h2",{attrs:{id:"缓存击穿-缓存穿透-缓存雪崩及污染的原因和解决方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存击穿-缓存穿透-缓存雪崩及污染的原因和解决方案"}},[s._v("#")]),s._v(" 缓存击穿，缓存穿透，缓存雪崩及污染的原因和解决方案？")]),s._v(" "),r("h2",{attrs:{id:"什么是哨兵模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是哨兵模式"}},[s._v("#")]),s._v(" 什么是哨兵模式？")]),s._v(" "),r("h2",{attrs:{id:"介绍一下rdb和aof机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#介绍一下rdb和aof机制"}},[s._v("#")]),s._v(" 介绍一下RDB和AOF机制？")]),s._v(" "),r("h2",{attrs:{id:"redis的发布订阅模式怎么做到的"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis的发布订阅模式怎么做到的"}},[s._v("#")]),s._v(" redis的发布订阅模式怎么做到的？")]),s._v(" "),r("h2",{attrs:{id:"redis集群如何实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis集群如何实现"}},[s._v("#")]),s._v(" redis集群如何实现？")])])}),[],!1,null,null,null);t.default=e.exports}}]);